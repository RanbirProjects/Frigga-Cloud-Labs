{"ast":null,"code":"var _jsxFileName = \"/Users/ranbirsingh/Desktop/figga cloud labs project/frontend/src/contexts/DocumentContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useReducer, useRef, useEffect, useCallback } from 'react';\nimport axios from 'axios';\nimport toast from 'react-hot-toast';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst DocumentContext = /*#__PURE__*/createContext();\nconst initialState = {\n  documents: [],\n  currentDocument: null,\n  loading: false,\n  error: null,\n  isConnected: true,\n  // Track connection status\n  pagination: {\n    current: 1,\n    pages: 1,\n    hasNext: false,\n    hasPrev: false\n  }\n};\nconst documentReducer = (state, action) => {\n  switch (action.type) {\n    case 'SET_LOADING':\n      return {\n        ...state,\n        loading: action.payload\n      };\n    case 'SET_ERROR':\n      return {\n        ...state,\n        error: action.payload,\n        loading: false,\n        isConnected: action.payload === 'Network Error' ? false : state.isConnected\n      };\n    case 'SET_CONNECTION_STATUS':\n      return {\n        ...state,\n        isConnected: action.payload,\n        error: action.payload ? null : state.error\n      };\n    case 'GET_DOCUMENTS_SUCCESS':\n      return {\n        ...state,\n        documents: action.payload.data,\n        pagination: action.payload.pagination,\n        loading: false,\n        error: null,\n        isConnected: true\n      };\n    case 'GET_DOCUMENT_SUCCESS':\n      return {\n        ...state,\n        currentDocument: action.payload,\n        loading: false,\n        error: null,\n        isConnected: true\n      };\n    case 'CREATE_DOCUMENT_SUCCESS':\n      return {\n        ...state,\n        documents: [action.payload, ...state.documents],\n        currentDocument: action.payload,\n        loading: false,\n        error: null,\n        isConnected: true\n      };\n    case 'UPDATE_DOCUMENT_SUCCESS':\n      return {\n        ...state,\n        documents: state.documents.map(doc => doc._id === action.payload._id ? action.payload : doc),\n        currentDocument: action.payload,\n        loading: false,\n        error: null,\n        isConnected: true\n      };\n    case 'DELETE_DOCUMENT_SUCCESS':\n      return {\n        ...state,\n        documents: state.documents.filter(doc => doc._id !== action.payload),\n        currentDocument: null,\n        loading: false,\n        error: null,\n        isConnected: true\n      };\n    case 'SEARCH_DOCUMENTS_SUCCESS':\n      return {\n        ...state,\n        documents: action.payload.data,\n        loading: false,\n        error: null,\n        isConnected: true\n      };\n    case 'SHARE_DOCUMENT_SUCCESS':\n      return {\n        ...state,\n        currentDocument: action.payload,\n        loading: false,\n        error: null,\n        isConnected: true\n      };\n    case 'CLEAR_CURRENT_DOCUMENT':\n      return {\n        ...state,\n        currentDocument: null\n      };\n    default:\n      return state;\n  }\n};\nexport const DocumentProvider = ({\n  children\n}) => {\n  _s();\n  const [state, dispatch] = useReducer(documentReducer, initialState);\n  const retryTimeoutRef = useRef(null);\n  const lastErrorRef = useRef(null);\n\n  // Cleanup timeout on unmount\n  useEffect(() => {\n    return () => {\n      if (retryTimeoutRef.current) {\n        clearTimeout(retryTimeoutRef.current);\n      }\n    };\n  }, []);\n\n  // Debounced error handling to prevent spam\n  const handleError = (error, defaultMessage) => {\n    var _error$response, _error$response$data;\n    const message = ((_error$response = error.response) === null || _error$response === void 0 ? void 0 : (_error$response$data = _error$response.data) === null || _error$response$data === void 0 ? void 0 : _error$response$data.message) || defaultMessage;\n    const isNetworkError = !error.response || error.code === 'ECONNREFUSED' || error.code === 'ERR_NETWORK';\n\n    // Don't show the same error repeatedly\n    if (lastErrorRef.current === message) {\n      return;\n    }\n    lastErrorRef.current = message;\n    dispatch({\n      type: 'SET_ERROR',\n      payload: message\n    });\n    if (isNetworkError) {\n      dispatch({\n        type: 'SET_CONNECTION_STATUS',\n        payload: false\n      });\n      // Retry connection after 5 seconds\n      if (retryTimeoutRef.current) {\n        clearTimeout(retryTimeoutRef.current);\n      }\n      retryTimeoutRef.current = setTimeout(() => {\n        // Try to reconnect by making a simple API call\n        axios.get('/api/auth/me').then(() => {\n          dispatch({\n            type: 'SET_CONNECTION_STATUS',\n            payload: true\n          });\n          lastErrorRef.current = null;\n          // Refresh documents after reconnection\n          getDocuments();\n        }).catch(() => {\n          // If still failing, try again in 10 seconds\n          retryTimeoutRef.current = setTimeout(() => {\n            dispatch({\n              type: 'SET_CONNECTION_STATUS',\n              payload: true\n            });\n            lastErrorRef.current = null;\n          }, 10000);\n        });\n      }, 5000);\n    } else {\n      toast.error(message);\n    }\n  };\n\n  // Get all documents\n  const getDocuments = useCallback(async (page = 1, limit = 10) => {\n    if (!state.isConnected) return;\n    dispatch({\n      type: 'SET_LOADING',\n      payload: true\n    });\n    try {\n      const res = await axios.get(`/api/documents?page=${page}&limit=${limit}`);\n      dispatch({\n        type: 'GET_DOCUMENTS_SUCCESS',\n        payload: {\n          data: res.data.data,\n          pagination: res.data.pagination\n        }\n      });\n      lastErrorRef.current = null; // Clear error on success\n    } catch (error) {\n      handleError(error, 'Failed to fetch documents');\n    }\n  }, [state.isConnected]);\n\n  // Get single document\n  const getDocument = useCallback(async id => {\n    if (!state.isConnected) return;\n    dispatch({\n      type: 'SET_LOADING',\n      payload: true\n    });\n    try {\n      const res = await axios.get(`/api/documents/${id}`);\n      dispatch({\n        type: 'GET_DOCUMENT_SUCCESS',\n        payload: res.data.data\n      });\n      lastErrorRef.current = null;\n    } catch (error) {\n      handleError(error, 'Failed to fetch document');\n    }\n  }, [state.isConnected]);\n\n  // Create document\n  const createDocument = async formData => {\n    if (!state.isConnected) {\n      toast.error('No connection to server');\n      return {\n        success: false,\n        message: 'No connection to server'\n      };\n    }\n    dispatch({\n      type: 'SET_LOADING',\n      payload: true\n    });\n    try {\n      const res = await axios.post('/api/documents', formData);\n      dispatch({\n        type: 'CREATE_DOCUMENT_SUCCESS',\n        payload: res.data.data\n      });\n      toast.success('Document created successfully!');\n      lastErrorRef.current = null;\n      return {\n        success: true,\n        document: res.data.data\n      };\n    } catch (error) {\n      var _error$response2, _error$response2$data;\n      const message = ((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : (_error$response2$data = _error$response2.data) === null || _error$response2$data === void 0 ? void 0 : _error$response2$data.message) || 'Failed to create document';\n      dispatch({\n        type: 'SET_ERROR',\n        payload: message\n      });\n      toast.error(message);\n      return {\n        success: false,\n        message\n      };\n    }\n  };\n\n  // Update document\n  const updateDocument = async (id, formData) => {\n    if (!state.isConnected) {\n      toast.error('No connection to server');\n      return {\n        success: false,\n        message: 'No connection to server'\n      };\n    }\n    dispatch({\n      type: 'SET_LOADING',\n      payload: true\n    });\n    try {\n      const res = await axios.put(`/api/documents/${id}`, formData);\n      dispatch({\n        type: 'UPDATE_DOCUMENT_SUCCESS',\n        payload: res.data.data\n      });\n      toast.success('Document updated successfully!');\n      lastErrorRef.current = null;\n      return {\n        success: true,\n        document: res.data.data\n      };\n    } catch (error) {\n      var _error$response3, _error$response3$data;\n      const message = ((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : (_error$response3$data = _error$response3.data) === null || _error$response3$data === void 0 ? void 0 : _error$response3$data.message) || 'Failed to update document';\n      dispatch({\n        type: 'SET_ERROR',\n        payload: message\n      });\n      toast.error(message);\n      return {\n        success: false,\n        message\n      };\n    }\n  };\n\n  // Delete document\n  const deleteDocument = async id => {\n    if (!state.isConnected) {\n      toast.error('No connection to server');\n      return {\n        success: false,\n        message: 'No connection to server'\n      };\n    }\n    dispatch({\n      type: 'SET_LOADING',\n      payload: true\n    });\n    try {\n      await axios.delete(`/api/documents/${id}`);\n      dispatch({\n        type: 'DELETE_DOCUMENT_SUCCESS',\n        payload: id\n      });\n      toast.success('Document deleted successfully!');\n      lastErrorRef.current = null;\n      return {\n        success: true\n      };\n    } catch (error) {\n      var _error$response4, _error$response4$data;\n      const message = ((_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : (_error$response4$data = _error$response4.data) === null || _error$response4$data === void 0 ? void 0 : _error$response4$data.message) || 'Failed to delete document';\n      dispatch({\n        type: 'SET_ERROR',\n        payload: message\n      });\n      toast.error(message);\n      return {\n        success: false,\n        message\n      };\n    }\n  };\n\n  // Search documents\n  const searchDocuments = async query => {\n    if (!state.isConnected) return;\n    dispatch({\n      type: 'SET_LOADING',\n      payload: true\n    });\n    try {\n      const res = await axios.get(`/api/documents/search?q=${encodeURIComponent(query)}`);\n      dispatch({\n        type: 'SEARCH_DOCUMENTS_SUCCESS',\n        payload: res.data\n      });\n      lastErrorRef.current = null;\n    } catch (error) {\n      handleError(error, 'Search failed');\n    }\n  };\n\n  // Share document\n  const shareDocument = async (id, email, permission) => {\n    if (!state.isConnected) {\n      toast.error('No connection to server');\n      return {\n        success: false,\n        message: 'No connection to server'\n      };\n    }\n    dispatch({\n      type: 'SET_LOADING',\n      payload: true\n    });\n    try {\n      const res = await axios.post(`/api/documents/${id}/share`, {\n        email,\n        permission\n      });\n      dispatch({\n        type: 'SHARE_DOCUMENT_SUCCESS',\n        payload: res.data.data\n      });\n      toast.success(res.data.message);\n      lastErrorRef.current = null;\n      return {\n        success: true\n      };\n    } catch (error) {\n      var _error$response5, _error$response5$data;\n      const message = ((_error$response5 = error.response) === null || _error$response5 === void 0 ? void 0 : (_error$response5$data = _error$response5.data) === null || _error$response5$data === void 0 ? void 0 : _error$response5$data.message) || 'Failed to share document';\n      dispatch({\n        type: 'SET_ERROR',\n        payload: message\n      });\n      toast.error(message);\n      return {\n        success: false,\n        message\n      };\n    }\n  };\n\n  // Remove collaborator\n  const removeCollaborator = async (documentId, userId) => {\n    dispatch({\n      type: 'SET_LOADING',\n      payload: true\n    });\n    try {\n      const res = await axios.delete(`/api/documents/${documentId}/share/${userId}`);\n      dispatch({\n        type: 'SHARE_DOCUMENT_SUCCESS',\n        payload: res.data.data\n      });\n      toast.success(res.data.message);\n      return {\n        success: true\n      };\n    } catch (error) {\n      var _error$response6, _error$response6$data;\n      const message = ((_error$response6 = error.response) === null || _error$response6 === void 0 ? void 0 : (_error$response6$data = _error$response6.data) === null || _error$response6$data === void 0 ? void 0 : _error$response6$data.message) || 'Failed to remove collaborator';\n      dispatch({\n        type: 'SET_ERROR',\n        payload: message\n      });\n      toast.error(message);\n      return {\n        success: false,\n        message\n      };\n    }\n  };\n\n  // Get document versions\n  const getDocumentVersions = async id => {\n    try {\n      const res = await axios.get(`/api/documents/${id}/versions`);\n      return {\n        success: true,\n        versions: res.data.data\n      };\n    } catch (error) {\n      var _error$response7, _error$response7$data;\n      const message = ((_error$response7 = error.response) === null || _error$response7 === void 0 ? void 0 : (_error$response7$data = _error$response7.data) === null || _error$response7$data === void 0 ? void 0 : _error$response7$data.message) || 'Failed to fetch versions';\n      toast.error(message);\n      return {\n        success: false,\n        message\n      };\n    }\n  };\n\n  // Restore document version\n  const restoreVersion = async (documentId, versionId) => {\n    dispatch({\n      type: 'SET_LOADING',\n      payload: true\n    });\n    try {\n      const res = await axios.post(`/api/documents/${documentId}/restore/${versionId}`);\n      dispatch({\n        type: 'UPDATE_DOCUMENT_SUCCESS',\n        payload: res.data.data\n      });\n      toast.success(res.data.message);\n      return {\n        success: true\n      };\n    } catch (error) {\n      var _error$response8, _error$response8$data;\n      const message = ((_error$response8 = error.response) === null || _error$response8 === void 0 ? void 0 : (_error$response8$data = _error$response8.data) === null || _error$response8$data === void 0 ? void 0 : _error$response8$data.message) || 'Failed to restore version';\n      dispatch({\n        type: 'SET_ERROR',\n        payload: message\n      });\n      toast.error(message);\n      return {\n        success: false,\n        message\n      };\n    }\n  };\n\n  // Clear current document\n  const clearCurrentDocument = () => {\n    dispatch({\n      type: 'CLEAR_CURRENT_DOCUMENT'\n    });\n  };\n  const value = {\n    documents: state.documents,\n    currentDocument: state.currentDocument,\n    loading: state.loading,\n    error: state.error,\n    pagination: state.pagination,\n    getDocuments,\n    getDocument,\n    createDocument,\n    updateDocument,\n    deleteDocument,\n    searchDocuments,\n    shareDocument,\n    removeCollaborator,\n    getDocumentVersions,\n    restoreVersion,\n    clearCurrentDocument\n  };\n  return /*#__PURE__*/_jsxDEV(DocumentContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 372,\n    columnNumber: 10\n  }, this);\n};\n_s(DocumentProvider, \"kfndogfGQ8nasGxOuknv1QPKtao=\");\n_c = DocumentProvider;\nexport const useDocument = () => {\n  _s2();\n  const context = useContext(DocumentContext);\n  if (!context) {\n    throw new Error('useDocument must be used within a DocumentProvider');\n  }\n  return context;\n};\n_s2(useDocument, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"DocumentProvider\");","map":{"version":3,"names":["React","createContext","useContext","useReducer","useRef","useEffect","useCallback","axios","toast","jsxDEV","_jsxDEV","DocumentContext","initialState","documents","currentDocument","loading","error","isConnected","pagination","current","pages","hasNext","hasPrev","documentReducer","state","action","type","payload","data","map","doc","_id","filter","DocumentProvider","children","_s","dispatch","retryTimeoutRef","lastErrorRef","clearTimeout","handleError","defaultMessage","_error$response","_error$response$data","message","response","isNetworkError","code","setTimeout","get","then","getDocuments","catch","page","limit","res","getDocument","id","createDocument","formData","success","post","document","_error$response2","_error$response2$data","updateDocument","put","_error$response3","_error$response3$data","deleteDocument","delete","_error$response4","_error$response4$data","searchDocuments","query","encodeURIComponent","shareDocument","email","permission","_error$response5","_error$response5$data","removeCollaborator","documentId","userId","_error$response6","_error$response6$data","getDocumentVersions","versions","_error$response7","_error$response7$data","restoreVersion","versionId","_error$response8","_error$response8$data","clearCurrentDocument","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","useDocument","_s2","context","Error","$RefreshReg$"],"sources":["/Users/ranbirsingh/Desktop/figga cloud labs project/frontend/src/contexts/DocumentContext.js"],"sourcesContent":["import React, { createContext, useContext, useReducer, useRef, useEffect, useCallback } from 'react';\nimport axios from 'axios';\nimport toast from 'react-hot-toast';\n\nconst DocumentContext = createContext();\n\nconst initialState = {\n  documents: [],\n  currentDocument: null,\n  loading: false,\n  error: null,\n  isConnected: true, // Track connection status\n  pagination: {\n    current: 1,\n    pages: 1,\n    hasNext: false,\n    hasPrev: false,\n  },\n};\n\nconst documentReducer = (state, action) => {\n  switch (action.type) {\n    case 'SET_LOADING':\n      return {\n        ...state,\n        loading: action.payload,\n      };\n    case 'SET_ERROR':\n      return {\n        ...state,\n        error: action.payload,\n        loading: false,\n        isConnected: action.payload === 'Network Error' ? false : state.isConnected,\n      };\n    case 'SET_CONNECTION_STATUS':\n      return {\n        ...state,\n        isConnected: action.payload,\n        error: action.payload ? null : state.error,\n      };\n    case 'GET_DOCUMENTS_SUCCESS':\n      return {\n        ...state,\n        documents: action.payload.data,\n        pagination: action.payload.pagination,\n        loading: false,\n        error: null,\n        isConnected: true,\n      };\n    case 'GET_DOCUMENT_SUCCESS':\n      return {\n        ...state,\n        currentDocument: action.payload,\n        loading: false,\n        error: null,\n        isConnected: true,\n      };\n    case 'CREATE_DOCUMENT_SUCCESS':\n      return {\n        ...state,\n        documents: [action.payload, ...state.documents],\n        currentDocument: action.payload,\n        loading: false,\n        error: null,\n        isConnected: true,\n      };\n    case 'UPDATE_DOCUMENT_SUCCESS':\n      return {\n        ...state,\n        documents: state.documents.map(doc =>\n          doc._id === action.payload._id ? action.payload : doc\n        ),\n        currentDocument: action.payload,\n        loading: false,\n        error: null,\n        isConnected: true,\n      };\n    case 'DELETE_DOCUMENT_SUCCESS':\n      return {\n        ...state,\n        documents: state.documents.filter(doc => doc._id !== action.payload),\n        currentDocument: null,\n        loading: false,\n        error: null,\n        isConnected: true,\n      };\n    case 'SEARCH_DOCUMENTS_SUCCESS':\n      return {\n        ...state,\n        documents: action.payload.data,\n        loading: false,\n        error: null,\n        isConnected: true,\n      };\n    case 'SHARE_DOCUMENT_SUCCESS':\n      return {\n        ...state,\n        currentDocument: action.payload,\n        loading: false,\n        error: null,\n        isConnected: true,\n      };\n    case 'CLEAR_CURRENT_DOCUMENT':\n      return {\n        ...state,\n        currentDocument: null,\n      };\n    default:\n      return state;\n  }\n};\n\nexport const DocumentProvider = ({ children }) => {\n  const [state, dispatch] = useReducer(documentReducer, initialState);\n  const retryTimeoutRef = useRef(null);\n  const lastErrorRef = useRef(null);\n\n  // Cleanup timeout on unmount\n  useEffect(() => {\n    return () => {\n      if (retryTimeoutRef.current) {\n        clearTimeout(retryTimeoutRef.current);\n      }\n    };\n  }, []);\n\n  // Debounced error handling to prevent spam\n  const handleError = (error, defaultMessage) => {\n    const message = error.response?.data?.message || defaultMessage;\n    const isNetworkError = !error.response || error.code === 'ECONNREFUSED' || error.code === 'ERR_NETWORK';\n    \n    // Don't show the same error repeatedly\n    if (lastErrorRef.current === message) {\n      return;\n    }\n    \n    lastErrorRef.current = message;\n    dispatch({ type: 'SET_ERROR', payload: message });\n    \n    if (isNetworkError) {\n      dispatch({ type: 'SET_CONNECTION_STATUS', payload: false });\n      // Retry connection after 5 seconds\n      if (retryTimeoutRef.current) {\n        clearTimeout(retryTimeoutRef.current);\n      }\n      retryTimeoutRef.current = setTimeout(() => {\n        // Try to reconnect by making a simple API call\n        axios.get('/api/auth/me')\n          .then(() => {\n            dispatch({ type: 'SET_CONNECTION_STATUS', payload: true });\n            lastErrorRef.current = null;\n            // Refresh documents after reconnection\n            getDocuments();\n          })\n          .catch(() => {\n            // If still failing, try again in 10 seconds\n            retryTimeoutRef.current = setTimeout(() => {\n              dispatch({ type: 'SET_CONNECTION_STATUS', payload: true });\n              lastErrorRef.current = null;\n            }, 10000);\n          });\n      }, 5000);\n    } else {\n      toast.error(message);\n    }\n  };\n\n  // Get all documents\n  const getDocuments = useCallback(async (page = 1, limit = 10) => {\n    if (!state.isConnected) return;\n    \n    dispatch({ type: 'SET_LOADING', payload: true });\n    try {\n      const res = await axios.get(`/api/documents?page=${page}&limit=${limit}`);\n      dispatch({\n        type: 'GET_DOCUMENTS_SUCCESS',\n        payload: {\n          data: res.data.data,\n          pagination: res.data.pagination,\n        },\n      });\n      lastErrorRef.current = null; // Clear error on success\n    } catch (error) {\n      handleError(error, 'Failed to fetch documents');\n    }\n  }, [state.isConnected]);\n\n  // Get single document\n  const getDocument = useCallback(async (id) => {\n    if (!state.isConnected) return;\n    \n    dispatch({ type: 'SET_LOADING', payload: true });\n    try {\n      const res = await axios.get(`/api/documents/${id}`);\n      dispatch({ type: 'GET_DOCUMENT_SUCCESS', payload: res.data.data });\n      lastErrorRef.current = null;\n    } catch (error) {\n      handleError(error, 'Failed to fetch document');\n    }\n  }, [state.isConnected]);\n\n  // Create document\n  const createDocument = async (formData) => {\n    if (!state.isConnected) {\n      toast.error('No connection to server');\n      return { success: false, message: 'No connection to server' };\n    }\n    \n    dispatch({ type: 'SET_LOADING', payload: true });\n    try {\n      const res = await axios.post('/api/documents', formData);\n      dispatch({ type: 'CREATE_DOCUMENT_SUCCESS', payload: res.data.data });\n      toast.success('Document created successfully!');\n      lastErrorRef.current = null;\n      return { success: true, document: res.data.data };\n    } catch (error) {\n      const message = error.response?.data?.message || 'Failed to create document';\n      dispatch({ type: 'SET_ERROR', payload: message });\n      toast.error(message);\n      return { success: false, message };\n    }\n  };\n\n  // Update document\n  const updateDocument = async (id, formData) => {\n    if (!state.isConnected) {\n      toast.error('No connection to server');\n      return { success: false, message: 'No connection to server' };\n    }\n    \n    dispatch({ type: 'SET_LOADING', payload: true });\n    try {\n      const res = await axios.put(`/api/documents/${id}`, formData);\n      dispatch({ type: 'UPDATE_DOCUMENT_SUCCESS', payload: res.data.data });\n      toast.success('Document updated successfully!');\n      lastErrorRef.current = null;\n      return { success: true, document: res.data.data };\n    } catch (error) {\n      const message = error.response?.data?.message || 'Failed to update document';\n      dispatch({ type: 'SET_ERROR', payload: message });\n      toast.error(message);\n      return { success: false, message };\n    }\n  };\n\n  // Delete document\n  const deleteDocument = async (id) => {\n    if (!state.isConnected) {\n      toast.error('No connection to server');\n      return { success: false, message: 'No connection to server' };\n    }\n    \n    dispatch({ type: 'SET_LOADING', payload: true });\n    try {\n      await axios.delete(`/api/documents/${id}`);\n      dispatch({ type: 'DELETE_DOCUMENT_SUCCESS', payload: id });\n      toast.success('Document deleted successfully!');\n      lastErrorRef.current = null;\n      return { success: true };\n    } catch (error) {\n      const message = error.response?.data?.message || 'Failed to delete document';\n      dispatch({ type: 'SET_ERROR', payload: message });\n      toast.error(message);\n      return { success: false, message };\n    }\n  };\n\n  // Search documents\n  const searchDocuments = async (query) => {\n    if (!state.isConnected) return;\n    \n    dispatch({ type: 'SET_LOADING', payload: true });\n    try {\n      const res = await axios.get(`/api/documents/search?q=${encodeURIComponent(query)}`);\n      dispatch({ type: 'SEARCH_DOCUMENTS_SUCCESS', payload: res.data });\n      lastErrorRef.current = null;\n    } catch (error) {\n      handleError(error, 'Search failed');\n    }\n  };\n\n  // Share document\n  const shareDocument = async (id, email, permission) => {\n    if (!state.isConnected) {\n      toast.error('No connection to server');\n      return { success: false, message: 'No connection to server' };\n    }\n    \n    dispatch({ type: 'SET_LOADING', payload: true });\n    try {\n      const res = await axios.post(`/api/documents/${id}/share`, { email, permission });\n      dispatch({ type: 'SHARE_DOCUMENT_SUCCESS', payload: res.data.data });\n      toast.success(res.data.message);\n      lastErrorRef.current = null;\n      return { success: true };\n    } catch (error) {\n      const message = error.response?.data?.message || 'Failed to share document';\n      dispatch({ type: 'SET_ERROR', payload: message });\n      toast.error(message);\n      return { success: false, message };\n    }\n  };\n\n  // Remove collaborator\n  const removeCollaborator = async (documentId, userId) => {\n    dispatch({ type: 'SET_LOADING', payload: true });\n    try {\n      const res = await axios.delete(`/api/documents/${documentId}/share/${userId}`);\n      dispatch({ type: 'SHARE_DOCUMENT_SUCCESS', payload: res.data.data });\n      toast.success(res.data.message);\n      return { success: true };\n    } catch (error) {\n      const message = error.response?.data?.message || 'Failed to remove collaborator';\n      dispatch({ type: 'SET_ERROR', payload: message });\n      toast.error(message);\n      return { success: false, message };\n    }\n  };\n\n  // Get document versions\n  const getDocumentVersions = async (id) => {\n    try {\n      const res = await axios.get(`/api/documents/${id}/versions`);\n      return { success: true, versions: res.data.data };\n    } catch (error) {\n      const message = error.response?.data?.message || 'Failed to fetch versions';\n      toast.error(message);\n      return { success: false, message };\n    }\n  };\n\n  // Restore document version\n  const restoreVersion = async (documentId, versionId) => {\n    dispatch({ type: 'SET_LOADING', payload: true });\n    try {\n      const res = await axios.post(`/api/documents/${documentId}/restore/${versionId}`);\n      dispatch({ type: 'UPDATE_DOCUMENT_SUCCESS', payload: res.data.data });\n      toast.success(res.data.message);\n      return { success: true };\n    } catch (error) {\n      const message = error.response?.data?.message || 'Failed to restore version';\n      dispatch({ type: 'SET_ERROR', payload: message });\n      toast.error(message);\n      return { success: false, message };\n    }\n  };\n\n  // Clear current document\n  const clearCurrentDocument = () => {\n    dispatch({ type: 'CLEAR_CURRENT_DOCUMENT' });\n  };\n\n  const value = {\n    documents: state.documents,\n    currentDocument: state.currentDocument,\n    loading: state.loading,\n    error: state.error,\n    pagination: state.pagination,\n    getDocuments,\n    getDocument,\n    createDocument,\n    updateDocument,\n    deleteDocument,\n    searchDocuments,\n    shareDocument,\n    removeCollaborator,\n    getDocumentVersions,\n    restoreVersion,\n    clearCurrentDocument,\n  };\n\n  return <DocumentContext.Provider value={value}>{children}</DocumentContext.Provider>;\n};\n\nexport const useDocument = () => {\n  const context = useContext(DocumentContext);\n  if (!context) {\n    throw new Error('useDocument must be used within a DocumentProvider');\n  }\n  return context;\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}